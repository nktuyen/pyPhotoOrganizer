#!/bin/python3
import concurrent.futures
import os
import sys
import optparse
import re
import datetime
import concurrent
import json
import PIL
import PIL.ExifTags
import PIL.Image
import exifread #Must be version 2.3.2
import ffmpeg
import stat


def organize_file(full_name: str, root_path: str, verbose: bool = False, hidden_files: bool = False, system_files: bool = False, excluded_patterns: list = None) -> None:
    """Organize file"""
    #Filter file by attributes
    try:
        file_stat = os.stat(full_name)
        if file_stat.st_file_attributes & stat.FILE_ATTRIBUTE_ARCHIVE:
            print(" - archive")
        if file_stat.st_file_attributes & stat.FILE_ATTRIBUTE_SYSTEM:
            print(" - system")
            if not system_files:
                if verbose:
                    print(f"{full_name} - Ignored: System file")
                return
        if file_stat.st_file_attributes & stat.FILE_ATTRIBUTE_HIDDEN:
            print(" - hidden")
            if not hidden_files:
                if verbose:
                    print(f"{full_name} - Ignored: Hidden file")
                return
        if file_stat.st_file_attributes & stat.FILE_ATTRIBUTE_READONLY:
            print(" - read only")
    except Exception as ex:
        pass
    
    relate_filename = full_name[len(root_path):]
    if relate_filename.startswith(os.sep):
        relate_filename = relate_filename[len(os.sep):]
    dir_name, file_name = os.path.split(full_name)
    file_title, file_ext = os.path.splitext(file_name)
    date_taken: str = None

    #Filter file by wildcard
    if isinstance(excluded_patterns, list):
        for pattern in excluded_patterns:
            if pattern == full_name or pattern == file_name:
                if verbose:
                    print(f"{full_name} - Ignored: Excluded file")
                return
            rex = re.compile('^' + pattern.replace('*',  '.*').replace('?', '.') + '$')
            if rex.match(full_name):
                if verbose:
                    print(f"{full_name} - Ignored: Excluded file")
                return

    #print(f"relate_filename={relate_filename}")
    #print(f"dir_name={dir_name}")
    #print(f"file_name={file_name}")
    #print(f"file_title={file_title}")
    #print(f"file_ext={file_ext}")

    if file_ext.upper() in [".HEIC"]:
        try:
            with open(full_name, 'rb') as heic_file:
                tags = exifread.process_file(heic_file)
                tag = tags["Image DateTime"]
                date_taken = tag.values
        except Exception as ex:
            if verbose:
                print(f"[HEIC]Exception:{ex}")
    elif file_ext.upper() in [".MP3", ".MP4", ".MOV", ".AVI", ".WMV"]:
        try:
            media = ffmpeg.probe(full_name)
            if media is not None:
                streams = media["streams"]
                for stream in  streams:
                    if stream is not None:
                        tags = stream["tags"]
                        if tags is not None:
                            if "creation_time" in tags:
                                date_taken = tags["creation_time"].replace("-", "")
                                break
        except Exception as ex:
            if verbose:
                print(f"Exception:{ex}")
    elif file_ext.upper() in [".BMP", ".JPG", ".PNG", ".JPEG", ".GIF", ".TIFF"]:
        try:
            img = PIL.Image.open(full_name)
            if img is not None:
                exif_data = img._getexif()
                if exif_data is not None:
                    try:
                        date_taken = exif_data[PIL.ExifTags.Base.DateTimeOriginal]
                    except:
                        pass
                    if date_taken is None or len(date_taken) == 0:
                        try:
                            date_taken = exif_data[PIL.ExifTags.Base.DateTimeDigitized]
                        except:
                            pass
                    if date_taken is None or len(date_taken) == 0:
                        try:
                            date_taken = exif_data[PIL.ExifTags.Base.DateTime]
                        except:
                            pass
        except Exception as ex:
            if verbose:
                print(f"Exception:{ex}")
    #Cannot extract meta data -> Determine creation date from file name or system created time
    if date_taken is None or len(date_taken) <= 0:
        r = re.compile(r"^([a-zA-Z_])([0-9]+)")
        m = r.match(file_title)
        if m:
            print(file_title)
            print(m)
            return
        else:
            try:
                c_time = os.path.getmtime(full_name)
                if c_time is not None:
                    local_time = datetime.datetime.fromtimestamp(c_time)
                    date_taken = str(local_time).replace("-", "")
            except Exception as ex:
                if verbose:
                    print(f"Exception:{ex}")
    
    if date_taken is None or len(date_taken) <= 0:
        full_name_new: str = os.path.join(root_path, file_name)
        if full_name_new.lower() == full_name.lower():
            if verbose:
                print(f"{full_name} - Ignored: Already in place")
            return
        relate_filename_new: str = full_name_new[len(root_path):]
        if relate_filename_new.startswith(os.sep):
            relate_filename_new = relate_filename_new[len(os.sep)]
        print(f"{relate_filename} => {relate_filename_new}")
        os.rename(full_name, full_name_new)
        return
    date_taken = date_taken.replace(":", "")
    year: str = date_taken[0:4]
    month: str = date_taken[4:6]
    day: str = date_taken[6:8]
    #print(f"date_taken={date_taken}")
    #print(f"year={year}")
    #print(f"month={month}")
    #print(f"day={day}")
    year_dir: str = os.path.join(root_path, year)
    #print(f"year_dir={year_dir}")
    if not os.path.exists(year_dir):
        os.mkdir(year_dir)
    month_dir: str = os.path.join(year_dir, month)
    #print(f"month_dir={month_dir}")
    if not os.path.exists(month_dir):
        os.mkdir(month_dir)
    full_name_new: str = os.path.join(month_dir, file_name)
    #print(f"full_name_new={full_name_new}")
    if full_name_new.lower() == full_name.lower():
        if verbose:
            print(f"{full_name} - Ignored: Already in place")
        return
    relate_filename_new: str = full_name_new[len(root_path):]
    if relate_filename_new.startswith(os.sep):
        relate_filename_new = relate_filename_new[len(os.sep):]
    print(f"{relate_filename} => {relate_filename_new}")
    os.rename(full_name, full_name_new)


def walkdir(args: tuple):
    """Walk on directory"""
    root = args[0]
    dir_to_walk = args[1]
    verbose: bool = args[2]
    recursive: bool = args[3]
    hidden_flag: bool = args[4]
    system_flag: bool = args[5]
    excluded_patterns: list = args[6]
    for parent, dirs, files in os.walk(dir_to_walk, topdown=True):
        for filename in files:
            full_filename:str = os.path.join(parent, filename)
            organize_file(full_filename, root, verbose, hidden_flag, system_flag, excluded_patterns)
        for dirname in dirs:
            walkdir((root, os.path.join(parent, dirname), verbose, recursive, hidden_flag, system_flag, excluded_patterns))

def main():
    """Main function"""
    parser: optparse.OptionParser = optparse.OptionParser('%prog [options] directories')
    parser.add_option("-j", "--jobs", default=2)
    parser.add_option("-v", "--verbose", action="store_false")
    parser.add_option("-r", "--recursive", action="store_false")
    parser.add_option("", "--hidden", action="store_false", help="Process hidden files")
    parser.add_option("", "--system", action="store_false", help="Process system files")
    parser.add_option("-x", "--exclude", default=None, help="Excluded patterns")

    opts,args = parser.parse_args()
    if len(args) == 0:
        parser.print_help()
        exit(0)
    
    directories: list = []
    for dirname in args:
        abs_path: str = os.path.abspath(dirname)
        if os.path.isdir(dirname):
            directories.append(abs_path)
        elif os.path.isdir(abs_path):
            directories.append(abs_path)
        else:
            print(f"{dirname} is not a valid direcotry")
    if len(directories) == 0:
        exit(1)
    
    verbose: bool = False
    recursive: bool = False
    hidden_files: bool = False
    system_files: bool = False
    excluded_pattern: list = []

    if opts.exclude is not None:
        temp_list: list = str(opts.exclude).split(',')
        for string in temp_list:
            l: list = string.split(';')
            for pattern in l:
                excluded_pattern.append(pattern.strip())
    if opts.verbose is not None:
        verbose = True
    if opts.recursive is not None:
        recursive = True
    if opts.hidden is not None:
        hidden_files = True
    if opts.system is not None:
        system_files = True
    args_list: list = []
    for dirname in directories:
        args_list.append((dirname, dirname, verbose, recursive, hidden_files, system_files, excluded_pattern))

    print(f"{'*'*50}")
    print(f"Jobs\t\t:{opts.jobs}")
    print(f"Verbose\t\t:{verbose}")
    print(f"Recursive\t:{recursive}")
    print(f"Hidden\t\t:{hidden_files}")
    print(f"System\t\t:{system_files}")
    print(f"Excluded\t:{excluded_pattern}")
    print(f"{'*'*50}")
    print()
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=int(opts.jobs)) as executor:
        future_to_dir = {executor.submit(walkdir, args) : args for args in args_list}

main()