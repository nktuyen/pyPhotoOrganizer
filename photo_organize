#!/bin/python3
import concurrent.futures
import os
import sys
import optparse
import re
import datetime
import concurrent
import json
import PIL
import PIL.ExifTags
import PIL.Image
import exifread #Must be version 2.3.2
import ffmpeg



def process_file(full_name: str, root_path: str, verbose: bool = False) -> None:
    relate_filename = full_name[len(root_path):]
    if relate_filename.startswith(os.sep):
        relate_filename = relate_filename[len(os.sep):]
    dir_name, file_name = os.path.split(full_name)
    file_title, file_ext = os.path.splitext(file_name)
    date_taken: str = None

    #print(f"relate_filename={relate_filename}")
    #print(f"dir_name={dir_name}")
    #print(f"file_name={file_name}")
    #print(f"file_title={file_title}")
    #print(f"file_ext={file_ext}")

    strings: list = relate_filename.split(os.sep)
    #if len(strings) == 3 and len(strings[0]) == 4 and len(strings[1]) == 2:
        #if verbose:
            #print(f"{relate_filename} is already satify")
        #return

    if file_ext.upper() in [".HEIC"]:
        try:
            with open(full_name, 'rb') as heic_file:
                tags = exifread.process_file(heic_file)
                tag = tags["Image DateTime"]
                date_taken = tag.values
        except Exception as ex:
            if verbose:
                print(f"[HEIC]Exception:{ex}")
    elif file_ext.upper() in [".MP3", ".MP4", ".MOV", ".AVI", ".WMV"]:
        try:
            media = ffmpeg.probe(full_name)
            if media is not None:
                streams = media["streams"]
                for stream in  streams:
                    if stream is not None:
                        tags = stream["tags"]
                        if tags is not None:
                            if "creation_time" in tags:
                                date_taken = tags["creation_time"].replace("-", "")
                                break
        except Exception as ex:
            if verbose:
                print(f"Exception:{ex}")
    elif file_ext.upper() in [".BMP", ".JPG", ".PNG", ".JPEG", ".GIF", ".TIFF"]:
        try:
            img = PIL.Image.open(full_name)
            if img is not None:
                exif_data = img._getexif()
                if exif_data is not None:
                    try:
                        date_taken = exif_data[PIL.ExifTags.Base.DateTimeOriginal]
                    except:
                        pass
                    if date_taken is None or len(date_taken) == 0:
                        try:
                            date_taken = exif_data[PIL.ExifTags.Base.DateTimeDigitized]
                        except:
                            pass
                    if date_taken is None or len(date_taken) == 0:
                        try:
                            date_taken = exif_data[PIL.ExifTags.Base.DateTime]
                        except:
                            pass
        except Exception as ex:
            if verbose:
                print(f"Exception:{ex}")
    #Cannot extract meta data -> Determine creation date from file name or system created time
    if date_taken is None or len(date_taken) <= 0:
        r = re.compile(r"^([a-zA-Z_])([0-9]+)")
        m = r.match(file_title)
        if m:
            print(file_title)
            print(m)
            return
        else:
            try:
                c_time = os.path.getmtime(full_name)
                if c_time is not None:
                    local_time = datetime.datetime.fromtimestamp(c_time)
                    date_taken = str(local_time).replace("-", "")
            except Exception as ex:
                if verbose:
                    print(f"Exception:{ex}")
    
    if date_taken is None or len(date_taken) <= 0:
        full_name_new: str = os.path.join(root_path, file_name)
        if full_name_new.lower() == full_name.lower():
            if verbose:
                print(f"{full_name} - Ignored")
            return
        relate_filename_new: str = full_name_new[len(root_path):]
        if relate_filename_new.startswith(os.sep):
            relate_filename_new = relate_filename_new[len(os.sep)]
        print(f"{relate_filename} => {relate_filename_new}")
        os.rename(full_name, full_name_new)
        return
    date_taken = date_taken.replace(":", "")
    year: str = date_taken[0:4]
    month: str = date_taken[4:6]
    day: str = date_taken[6:8]
    #print(f"date_taken={date_taken}")
    #print(f"year={year}")
    #print(f"month={month}")
    #print(f"day={day}")
    year_dir: str = os.path.join(root_path, year)
    #print(f"year_dir={year_dir}")
    if not os.path.exists(year_dir):
        os.mkdir(year_dir)
    month_dir: str = os.path.join(year_dir, month)
    #print(f"month_dir={month_dir}")
    if not os.path.exists(month_dir):
        os.mkdir(month_dir)
    full_name_new: str = os.path.join(month_dir, file_name)
    #print(f"full_name_new={full_name_new}")
    if full_name_new.lower() == full_name.lower():
        if verbose:
            print(f"{full_name} - Ignore")
        return
    relate_filename_new: str = full_name_new[len(root_path):]
    if relate_filename_new.startswith(os.sep):
        relate_filename_new = relate_filename_new[len(os.sep):]
    print(f"{relate_filename} => {relate_filename_new}")
    os.rename(full_name, full_name_new)


def walkdir(args: tuple):
    root = args[0]
    dir = args[1]
    verbose: bool = args[2]
    recursive: bool = args[3]
    result: dict = {}
    for parent, dirs, files in os.walk(dir, topdown=True):
        for filename in files:
            full_filename:str = os.path.join(parent, filename)
            process_file(full_filename, root, verbose)
        for dirname in dirs:
            walkdir((root, os.path.join(parent, dirname), verbose, recursive))
    return result


def main():
    parser: optparse.OptionParser = optparse.OptionParser('%prog [options] directories')
    parser.add_option("-v", "--verbose", action="store_false")
    parser.add_option("-j", "--jobs", default=2)
    parser.add_option("-r", "--recursive", action="store_false")
    opts,args = parser.parse_args()
    if len(args) == 0:
        parser.print_help()
        exit(0)
    
    directories: list = []
    for dir in args:
        abs_path: str = os.path.abspath(dir)
        if os.path.isdir(dir):
            directories.append(abs_path)
        elif os.path.isdir(abs_path):
            directories.append(abs_path)
        else:
            print("%s is not a valid direcotry" % dir)
    if len(directories) == 0:
        exit(1)
    
    verbose: bool = False
    recursive: bool = False
    if opts.verbose is not None:
        verbose = True
    if opts.recursive is not None:
        recursive = True
    args_list: list = []
    for dir in directories:
        args_list.append((dir, dir, verbose, recursive))

    print(f"jobs:{opts.jobs}")
    print(f"verbose:{verbose}")
    print(f"recursive:{recursive}")
    print()
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=int(opts.jobs)) as executor:
        future_to_dir = {executor.submit(walkdir, args) : args for args in args_list}

main()